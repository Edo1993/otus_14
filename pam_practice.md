# otus_14
# PAM
1. Запретить всем пользователям, кроме группы admin логин в выходные (суббота и воскресенье), без учета праздников

# Подготовка стенда к работе
На стендовой виртуальной машине создадим 3х пользователей:
```
sudo useradd day && \
sudo useradd night && \
sudo useradd friday
```
Назначим им пароли:
```
echo "Otus2019"|sudo passwd --stdin day &&\
echo "Otus2019" | sudo passwd --stdin night &&\
echo "Otus2019" | sudo passwd --stdin friday
```
Чтобы быть уверенными, что на стенде разрешен вход через ssh по паролю выполним:
```
sudo bash -c "sed -i 's/^PasswordAuthentication.*$/PasswordAuthentication yes/' /etc/ssh/sshd_config && systemctl restart sshd.service"
```
# Модуль pam_time

Модуль pam_time позволяет достаточно гибко настроить доступ пользователя с учетом времени. Настройки данного модуля хранятся в файле /etc/security/time.conf.
```
cd /etc/security/
sudo vi time.conf
```
Добавим в конец файла строки
```
*;*;day;Al0800-2000
*;*;night;!Al0800-2000
*;*;friday;Fr
```
Теперь настроим PAM, так как по-умолчанию данный модуль не подключен.
Для этого приведем файл ```/etc/pam.d/sshd``` к виду:
```
...
account required pam_nologin.so
account required pam_time.so
...
```
![Image alt](https://github.com/Edo1993/otus_14/raw/master/Screenshot_76.png)

После чего в отдельном терминале можно проверить доступ к серверу по ssh для созданных пользователей.
Пользователь day

![Image alt](https://github.com/Edo1993/otus_14/raw/master/Screenshot_69.png)

Пользователь night

![Image alt](https://github.com/Edo1993/otus_14/raw/master/Screenshot_70.png)

Пользователь friday

![Image alt](https://github.com/Edo1993/otus_14/raw/master/Screenshot_71.png)

Проверяем попутки успешных входов ```last```
![Image alt](https://github.com/Edo1993/otus_14/raw/master/Screenshot_75.png)

После этого захотелось проверить, что для пользователя friday всё работает корректно. Изменила в ```/etc/security/time.conf``` для пользователя friday день на субботу Sa:

![Image alt](https://github.com/Edo1993/otus_14/raw/master/Screenshot_72.png)

Систему рестартанула - пользователю отказано в доступе (без рестратра - его спокойно пускало).

![Image alt](https://github.com/Edo1993/otus_14/raw/master/Screenshot_73.png)

Проверяем попутки Неуспешных входов ```lastb```

![Image alt](https://github.com/Edo1993/otus_14/raw/master/Screenshot_75_1.png)

# Модуль pam_exec

*Предварительную подготовку стенда также выполняем, если переходим на другую машину*

Еще один способ реализовать задачу - выполнить при подключении пользователя скрипт, в котором необходимая информация обработается самостоятельно.
Удалим из /etc/pam.d/sshd изменения из предыдущего этапа и приведем его к следующему виду:
```
...
account required pam_nologin.so
account required pam_exec.so /usr/local/bin/test_login.sh
...
```
![Image alt](https://github.com/Edo1993/otus_14/raw/master/21.png)

Добавлен модуль ```pam_exec``` и, в качестве параметра, указан скрипт, который осуществит необходимые проверки. [Скрипт](https://gist.github.com/dmitry-lyutenko/39bf8afe5d1f6fc2d48b09c325706495) взят готовый.
При запуске данного скрипта PAM-модулем будет передана переменная окружения PAM_USER, содержащая имя пользователя.

*У меня почему-то были косяки с тем, что после всех действий проверки не работали и пускало всё равно всех пользаков, поэтому скрипту я изменила права на выполнение*

```
chmod 777 test_login.sh 
```
После этого проверки на вход начали выполняться корректно.

Пользователь day

![Image alt](https://github.com/Edo1993/otus_14/raw/master/24.png)

Пользователь night

![Image alt](https://github.com/Edo1993/otus_14/raw/master/23.png)

Пользователь friday

![Image alt](https://github.com/Edo1993/otus_14/raw/master/22.png)

# Модуль pam_script

Согласно методичке - не взлетело, отложено на потом. day, night, friday выполняют вход без ограничений.

Разобрано в рамках выполнения домашней работы. В методичке для модуля *account* было указано, в результате поднялось в модулем *auth*.

# Модуль pam_cap

Для демонстрации работы модуля установим дополнительный пакет nmap-ncat(CentOS)

```sudo yum install nmap-ncat -y```

Пользователь *day* остался из предыдущего примера.

Войдем на стендовую машину под пользователем *day* и попробуем выполнить команду ```ncat -l -p 80``` и получим сообщение об ошибке. Это связано с тем, что непривелигерованный пользователь day, от имени которого выполняется команда, не может открыть для прослушивания 80й порт.

![Image alt](https://github.com/Edo1993/otus_14/raw/master/41.png)

Предоставим пользователю права (возможности), чтобы он смог открыть порт. Способ более гибкий, потому что можно
указать что именно, кому и при помощи какой программы разрешаем. Для этого воспользумся pam-модулем ```pam_cap```. Поскольку это демо-стенд, то SELinux можно выключить, выполнив
```
sudo setenforce 0
```

Приведем файл /etc/pam.d/sshd к виду (если стенд голый - то добавляется только строка ```auth required pam_cap.so```, т.к я издевалась над своим стендом долго, то из /etc/pam.d/sshd также пришлось выпилить все предыдущие свои следы):

```
...
auth include postlogin
auth required pam_cap.so
...
```

Таким образом, мы включили обработку *capabilities* при подключении по ssh. Пропишем необходимые права пользователю *day*. Для этого создадим файл ```/etc/security/capability.conf```, содержащий одну строку:

```
cap_net_bind_service day
```

Теперь необходимо программе (```/usr/bin/ncat```), при помощи которой будет открываться порт, так же выдать разрешение на данное действие:
```
sudo setcap cap_net_bind_service=ei /usr/bin/ncat
```
Мы сопоставили права, выданные пользователю с правами выданными на программу. Снова зайдем на стенд под пользователем
*day* и проверим, что мы получили необходимые права:

```
capsh --print
```

Теперь попробуем выполнить команду:
```
ncat -l -p 80
```
Теперь ошибки не возникло. Теперь можно открыть еще одну ssh-консоль также от пользователя *day* и там выполнить:

```
echo "Make Linux great again" > /dev/tcp/127.0.0.7/80
```

Сообщение ```Make Linux great again``` отобразится в первой консоли

Обе консоли + мои неудачные попытки

![Image alt](https://github.com/Edo1993/otus_14/raw/master/42.png)

# Права администратора

Помимо внесения ограничений на вход пользователя в систему, мы так же можем предоставить выбранному пользователю разные права. Для примера рассмотрим предоставление прав *root'а* определеному пользователю в системе. Обычно для этого используются следующие варианты:

● пользователь заносится в группу wheel;

● для него создается отдельный файл в /etc/sudoers.d/;

● отдельная строка в /etc/sudoers.

● *Первый способ* реализуется очень просто.

Зайдя в систему под *root'ом* нужно выполнить:
```
usermod -G wheel day
```
Теперь зайдя в систему под пользователем *day* можно выполнить команду ```sudo -i``` и получить консоль пользователя *root*. При этом будет запрошен пароль того пользователя, под которым осуществлен вход в систему (в данном случае day).

![Image alt](https://github.com/Edo1993/otus_14/raw/master/51.png)

● *Второй способ - отдельный файл в /etc/sudoers.d/*

Под пользователем *root* создадим файл для пользователя *friday* в ```/etc/sudoers.d/``` (итого, полный адрес файла - /etc/sudoers.d/friday), состоящий из единственной строки:

```
friday ALL=(ALL) NOPASSWD: ALL
```
Теперь ```sudo``` под пользователем friday не попросит пароля.

![Image alt](https://github.com/Edo1993/otus_14/raw/master/53.png)

● *Третий способ - отдельная строка в /etc/sudoers*

Зайдя в систему под *root'ом* редактируем файл ```/etc/sudoers```, добавляем строку 
```
night ALL=(ALL) ALL
```
Данный вариант по-прежнему будет спрашивать пароль текущего пользователя.

![Image alt](https://github.com/Edo1993/otus_14/raw/master/52.png)
